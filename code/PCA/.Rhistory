x <- IRanges(start=c(4, 7, 2, 20), end=c(13, 7, 5, 23))
x
# name them:
names(x) <- letters[1:4]
class(x)
width(x)
end(x)
end(x)
# and can increment them; ie add 4 to the end of all ranges
end(x) <- end(x) + 4
end(x)
# look at all of the ranges within the IRanges object:
range(x)
x
# access individual ranges out of IRange object with subsetting
x[2:3]
start(x) <5
x[start(x)<5]
x[width(x)>8]
# and concatenate ranges:
a <- IRanges(start=7, width=4)
b <- IRanges(start=2, end=5)
c <- c(a,b)
c
# grow or shrink objects using normal math:
x <- IRanges(start=c(40, 80), end=c(67, 114))
x + 4L
x - 10L
x-20L
# can restrict ranges to within particular bounds:
y <- IRanges(start=c(4, 6, 10, 12), width=13)
y
restrict(y, 5, 10)
# make new ranges based on relation to ranges you already have
flank(x, width=7) #makes ranges upstream of x with width=7
promoters <- flank(x, width=20)
# make new ranges based on relation to ranges you already have
flank(x, width=7) #makes ranges upstream of x with width=7
flank(x, width=7, start=F) #makes range downstream
promoters <- flank(x, width=20)
# find total coverage with reduce()
# reduces a bunch of ranges into one "super read"
# start with random reads as an example:
set.seed(0) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5)
head(alns, 10)
reduce(alns)
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed() # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
?set.seed
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed(1) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
reduce(alns) #so this shows the ranges that we have coverage
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed(100) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
reduce(alns) #so this shows the ranges that we have coverage
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed(0) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
reduce(alns) #so this shows the ranges that we have coverage
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed(927) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
reduce(alns) #so this shows the ranges that we have coverage
# or find where you DON'T have coverage with gaps()
gaps(alns)
# find total coverage with reduce()
# reduces a bunch of ranges into a "super read"
# start with random reads as an example:
set.seed(0) # set the random number generator seed
alns <- IRanges(start=sample(seq_len(50), 20), width=5) # sample 20 reads of width 5 in the range 0 - 50 for the start site
head(alns, 10)
reduce(alns) #so this shows the ranges that we have coverage
# or find where you DON'T have coverage with gaps()
gaps(alns)
# the IRange ranges also count as a sequence of integers, so
all.equal(IRange(start=4, end=7), c(4:7))
# the IRange ranges also count as a sequence of integers, so
y <- IRange(start=4, end=7)
# the IRange ranges also count as a sequence of integers, so
y <- IRanges(start=4, end=7)
all.equal(y, c(4:7))
# this is the integers 4,5,6,7
# so you can use normal R operations:
a <- IRanges(start=4, end=13)
b <- IRanges(start = 12, end=17)
setdiff(a,b)
setdiff(b,a)
# Look for overlaps between a query and subject range:
qry <- IRanges(start=c(1, 26, 19, 11, 21, 7), end=c(16, 30, 19, 15, 24, 8),
names=letters[1:6])
sbj <- IRanges(start=c(1, 19, 10), end=c(5, 29, 16), names=letters[24:26])
hits <- findOverlaps(qry, sbj)
hits
names(qry)[queryHits(hts)]
hts <- findOverlaps(qry, sbj)
names(qry)[queryHits(hts)]
names(sbj)[subjectHits(hts)]
# findOverlaps() uses ANY overlap, even one bp, to count as an overlap
# can change with "type":
hts_within <- findOverlaps(qry, sbj, type="within")
hts_within
hts
# And, you can limit hits to a single match between subject and query
# either the first, last, or random match:
findOverlaps(qry, sbj, select="first")
findOverlaps(qry, sbj, select="last")
findOverlaps(qry, sbj, select="arbitrary")
# make it computationally better by making an "interval tree"
# to tell R where the endpoints even are and limit searchspace
sbj_it <- IntervalTree(sbj)
class(sbj_it)
?IntervalTree
# make it computationally MUCH better by making an "interval tree"
# to tell R where the endpoints even are and limit searchspace
# sbj_it <- IntervalTree(sbj)
# OK there's an update use NCList instead:
sbj_it <- NCList(sbj)
class(sbj_it)
findOverlaps(qry, sbj_it)
# other functions:
as.matrix(hts)
typeof(hts)
typeof(as.matrix(hts))
countQueryHits(hts)
qry
sbj
countSubjectHits(hts)
setNames(countQueryHits(hts), names(qry))
# Look for subject ranges nearby query:
qry <- IRanges(start=6, end=13, name='query')
sbj <- IRanges(start=c(2, 4, 18, 19), end=c(4, 7, 21, 24), names=1:4)
nearest(qry, sbj)
precede(qry, sbj)
follow(qry, sbj)
# GENOMIC ranges:
# similar to IRanges but better for genomic stuff:
library(GenomicRanges)
gr <- GRanges(seqname=c("chr1", "chr1", "chr2", "chr3"),
ranges=IRanges(start=5:8, width=10),
strand=c("+", "-", "-", "+"))
gr
# and can have metadat
gr <- GRanges(seqname=c("chr1", "chr1", "chr2", "chr3"), ranges=IRanges(start=5:8, width=10),
strand=c("+", "-", "-", "+"), gc=round(runif(4), 3))
devtools::install_github("QTCAT/qtcat")
devtools::install_github("QTCAT/qtcat")
devtools::install_github("QTCAT/qtcat.data")
#------------------------------------------------------------------------------#
# load data
data("snp")
require(qtcat)
require(qtcat.data)
library(devtools)
install_github("QTCAT/qtcat")
install_github("QTCAT/qtcat")
library(devtools)
install_github("QTCAT/qtcat")
install.packages("hit")
install.packages("qtcat")
remote::install_github("QTCAT/qtcat.data")
remotes::install_github("QTCAT/qtcat.data")
install.packages("remotes")
remotes::install_github("QTCAT/qtcat.data")
remotes::install_github("QTCAT/qtcat")
seq <- 'GACTTAATGGGCAATAGGCAAGCACTTGAAAAAGATGCCAACGACATGAAAACACAAGACAA'
count <-  0
for i in seq_along(seq) {
if (seq[i] == "G") {
count <- count + 1
}
}
for (i in seq_along(seq)) {
if (seq[i] == "G") {
count <- count + 1
}
}
print(count)
seq <- c('G,A,C,T,T,A,A,T,G,G,G,C,A,A,T,A,G,G,C,A,A,G,C,A,C,T,T,G,A,A,A,A,A,G,A,T,G,C,C,A,A,C,G,A,C,A,T,G,A,A,A,A,C,A,C,A,A,G,A,C,A,A)'
seq <- c("G","A","C","T","T","A","A",'T','G','G','G','C','A','A','T','A','G','G','C','A','A','G','C','A','C','T','T','G','A','A','A','A','A','G','A','T','G','C','C','A','A','C','G','A','C','A','T','G','A','A','A','A','C','A','C','A','A','G','A','C','A','A')
strsplit(seq, "")
seq  <- 'GACTTAATGGGCAATAGGCAAGCACTTGAAAAAGATGCCAACGACATGAAAACACAAGACAA'
seq <- strsplit(seq, "")[[1]]
count <-  0
for (i in seq_along(seq)) {
if (seq[i] == "G") {
count <- count + 1
}
}
print(count)
?strcount()
library(stringr)
?str_count
?cbind
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/ltibbs/Box Sync/ISU/2018 fall/BCB 546X Computational Skills for Bio Data/final project")
library(tidyverse)
library(readxl)
full.geno <- read_csv("supplemental/Suppl_Table_2.csv")
head(full.geno)
tr.geno <- as_tibble(cbind(SNPs=colnames(full.geno), t(full.geno))) # transpose full.geno and cbind the SNP names to it
colnames(tr.geno) <- tr.geno[1,] # add the column names since they were moved to row 1 by t()
tr.geno <- tr.geno[-1,] # remove row 1 now that column names are where they should be
head(tr.geno) # visually inspect transposed geno file
num.geno <- tr.geno %>%
unite(united, -1, sep="", remove=F) %>%
mutate(count.A=str_count(united, "A"), # count each nucleotide in the SNPs
count.C=str_count(united,"C"),
count.G=str_count(united, "G"),
count.T=str_count(united,"T"),
max.count=pmax(count.A, count.C, count.G, count.T), # find the max count of any NT for a given SNP
ref.allele=ifelse(count.A==max.count, "A", # set the reference allele
ifelse(count.C==max.count, "C",
ifelse(count.G==max.count, "G", "T")))
) %>%
group_by(ref.allele) # group by reference allele value
# split the genotype data into tibbles each with the same reference allele, and store these in a list
split.num.geno <- split(num.geno, num.geno$ref.allele)
# loop through each tibble in the list to replace homozygous reference as 2, het as 1, missing as 9, and other as 0:
for (i in 1:length(split.num.geno)) {
ref <- unique(split.num.geno[[i]]$ref.allele) # save ref allele
stopifnot(length(ref)==1) # check that there was only one ref allele in the table
geno.index <- ncol(split.num.geno[[i]])-6 # store the index of the last column with genotype data
# make string of heterozygous genotypes to match (code idea from https://stackoverflow.com/questions/35366803/how-to-use-gsub-for-the-list-of-multiple-patterns-in-r)
het.list <- list(paste(ref, "A", sep=""), paste(ref, "C", sep=""), paste(ref, "G", sep=""), paste(ref, "T", sep=""),
paste("A", ref, sep=""), paste("C", ref, sep=""), paste("G", ref, sep=""), paste("T", ref, sep="")) # list possible het genotypes (refref genotype will also occur in this list, but will not be matched because that pattern will be replaced first)
het.string <- paste(unlist(het.list), collapse="|") # convert this list into a string separated by | to match any of these patterns
split.num.geno[[i]] <- split.num.geno[[i]] %>% # in the following lines, use c(2:geno.index) to make replacements only in the coluns containing genotype data
mutate_at(c(2:geno.index), funs(replace(., is.na(.), "9"))) %>% # replace missing data with 9
mutate_at(c(2:geno.index), funs(str_replace_all(., paste(ref, ref, sep=""), "2"))) %>% # replace homozygous ref genotypes with 2
mutate_at(c(2:geno.index), funs(str_replace_all(., het.string, "1"))) %>% # replace het genotypes with 1
mutate_at(c(2:geno.index), funs(str_replace_all(., "[[:upper:]]{2}", "0"))) %>% # replace all remaining genotypes with 0
select(-count.A, -count.C, -count.T, -count.G, -united, -max.count) # remove non-genotype columns
}
full.indiv <- read_csv("12864_2015_1444_MOESM1_ESM.csv")
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.csv")
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.txt")
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.txt") # this file was attached as a ".csv" in the paper's supplemental data, but inspecting the file showed that it was actually a tsv file, so I manually changed the file extension
head(full.indiv)
full.indiv
View(full.indiv)
unique(full.indiv$species)
plyr::count(full.indiv$species)
unique(full.indiv$group1)
plyr::count(full.indiv$group2)
eigensoft.geno <- do.call("rbind", split.num.geno) %>% # combine tibbles in list
ungroup() %>%
select(-ref.allele, -X1) # remove unneeded columns
# save the full dataset in eigensoft format
full.eigensoft.geno <- unite(eigensoft.geno, united, sep="", remove=T) # collapse all SNPs into one line
View(eigensoft.geno)
eigensoft.geno
full.indiv$Accession
"BGV007931" %in% full.indiv$Accession
line.order <- colnames(eigensoft.geno)
duplicated(colnames(eigensoft.geno))
plyr::count(duplicated(colnames(eigensoft.geno)))
plyr::count(duplicated(full.indiv$Accession))
plyr::count(duplicated(colnames(eigensoft.geno)))
plyr::count(duplicated(full.indiv$Accession))
geno.only <- setdiff(colnames(eigensoft.geno), full.indiv$Accession)
indiv.only <- setdiff(full.indiv$Accession, colnames(eigensoft.geno))
shared <- intersect(colnames(eigensoft.geno), full.indiv$Accession)
View(geno.only)
View(index.only)
View(indiv.only)
indiv.only
colnames(eigensoft.geno) <- tolower(as.character(colnames(eigensoft.geno)))
eigensoft.geno
full.indiv$Accession <- tolower(as.character(full.indiv$Accession))
full.indiv$Accession
full.indiv
plyr::count(duplicated(colnames(eigensoft.geno))) # so this has no duplicates
plyr::count(duplicated(full.indiv$Accession)) # but this DOES have duplicates ...
#remove spaces
colnames(eigensoft.geno) <- gsub(" ", "", colnames(eigensoft.geno))
eigensoft.geno
plyr::count(duplicated(colnames(eigensoft.geno))) # so this has no duplicates
full.indiv$Accession <- gsub(" ", "", full.indiv$Accession)
full.indiv
plyr::count(duplicated(colnames(eigensoft.geno))) # so this has no duplicates
plyr::count(duplicated(full.indiv$Accession)) # but this DOES have duplicates ...
geno.only <- setdiff(colnames(eigensoft.geno), full.indiv$Accession)
indiv.only <- setdiff(full.indiv$Accession, colnames(eigensoft.geno))
shared <- intersect(colnames(eigensoft.geno), full.indiv$Accession)
# remove special characters
colnames(eigensoft.geno) <- gsub("_", "", colnames(eigensoft.geno))
full.indiv$Accession <- gsub("_", "", full.indiv$Accession)
geno.only <- setdiff(colnames(eigensoft.geno), full.indiv$Accession)
indiv.only <- setdiff(full.indiv$Accession, colnames(eigensoft.geno))
shared <- intersect(colnames(eigensoft.geno), full.indiv$Accession)
View(shared)
eigensoft.geno <- do.call("rbind", split.num.geno) %>% # combine tibbles in list
ungroup() %>%
select(-ref.allele, -X1) # remove unneeded columns
# save the full dataset in eigensoft format
full.eigensoft.geno <- unite(eigensoft.geno, united, sep="", remove=T) # collapse all SNPs into one line
# output file
write_tsv(eigensoft.geno, "full.eigensoft.geno", col_names = F)
pre.indiv <- tibble(colnames(eigensoft.geno), c(rep("U", 1008)))
pre.indiv <- tibble(colnames(eigensoft.geno), c(rep("U", length(colnames(eigensoft.geno)))))
pre.indiv <- tibble(accessions=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
pre.indiv <- tibble(accession=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
View(pre.indiv)
?left_join
pre.indiv <- tibble(Accession=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
indiv.join <- left_join(pre.indiv, full.indiv)
View(indiv.join)
plyr::count(is.na(indiv.join$species))
plyr::count(colnames(eigensoft.geno) %in% full.indiv$Accession)
geno.only <- setdiff(colnames(eigensoft.geno), full.indiv$Accession)
indiv.only <- setdiff(full.indiv$Accession, colnames(eigensoft.geno))
shared <- intersect(colnames(eigensoft.geno), full.indiv$Accession)
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/ltibbs/Box Sync/ISU/2018 fall/BCB 546X Computational Skills for Bio Data/final project")
library(tidyverse)
library(readxl)
full.geno <- read_csv("supplemental/Suppl_Table_2.csv")
head(full.geno)
tr.geno <- as_tibble(cbind(SNPs=colnames(full.geno), t(full.geno))) # transpose full.geno and cbind the SNP names to it
colnames(tr.geno) <- tr.geno[1,] # add the column names since they were moved to row 1 by t()
tr.geno <- tr.geno[-1,] # remove row 1 now that column names are where they should be
head(tr.geno) # visually inspect transposed geno file
num.geno <- tr.geno %>%
unite(united, -1, sep="", remove=F) %>%
mutate(count.A=str_count(united, "A"), # count each nucleotide in the SNPs
count.C=str_count(united,"C"),
count.G=str_count(united, "G"),
count.T=str_count(united,"T"),
max.count=pmax(count.A, count.C, count.G, count.T), # find the max count of any NT for a given SNP
ref.allele=ifelse(count.A==max.count, "A", # set the reference allele
ifelse(count.C==max.count, "C",
ifelse(count.G==max.count, "G", "T")))
) %>%
group_by(ref.allele) # group by reference allele value
# split the genotype data into tibbles each with the same reference allele, and store these in a list
split.num.geno <- split(num.geno, num.geno$ref.allele)
# loop through each tibble in the list to replace homozygous reference as 2, het as 1, missing as 9, and other as 0:
for (i in 1:length(split.num.geno)) {
ref <- unique(split.num.geno[[i]]$ref.allele) # save ref allele
stopifnot(length(ref)==1) # check that there was only one ref allele in the table
geno.index <- ncol(split.num.geno[[i]])-6 # store the index of the last column with genotype data
# make string of heterozygous genotypes to match (code idea from https://stackoverflow.com/questions/35366803/how-to-use-gsub-for-the-list-of-multiple-patterns-in-r)
het.list <- list(paste(ref, "A", sep=""), paste(ref, "C", sep=""), paste(ref, "G", sep=""), paste(ref, "T", sep=""),
paste("A", ref, sep=""), paste("C", ref, sep=""), paste("G", ref, sep=""), paste("T", ref, sep="")) # list possible het genotypes (refref genotype will also occur in this list, but will not be matched because that pattern will be replaced first)
het.string <- paste(unlist(het.list), collapse="|") # convert this list into a string separated by | to match any of these patterns
split.num.geno[[i]] <- split.num.geno[[i]] %>% # in the following lines, use c(2:geno.index) to make replacements only in the coluns containing genotype data
mutate_at(c(2:geno.index), funs(replace(., is.na(.), "9"))) %>% # replace missing data with 9
mutate_at(c(2:geno.index), funs(str_replace_all(., paste(ref, ref, sep=""), "2"))) %>% # replace homozygous ref genotypes with 2
mutate_at(c(2:geno.index), funs(str_replace_all(., het.string, "1"))) %>% # replace het genotypes with 1
mutate_at(c(2:geno.index), funs(str_replace_all(., "[[:upper:]]{2}", "0"))) %>% # replace all remaining genotypes with 0
select(-count.A, -count.C, -count.T, -count.G, -united, -max.count) # remove non-genotype columns
}
eigensoft.geno <- do.call("rbind", split.num.geno) %>% # combine tibbles in list
ungroup() %>%
select(-ref.allele, -X1) # remove unneeded columns
# save the full dataset in eigensoft format
full.eigensoft.geno <- unite(eigensoft.geno, united, sep="", remove=T) # collapse all SNPs into one line
# output file
write_tsv(eigensoft.geno, "full.eigensoft.geno", col_names = F)
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.txt") # this file was attached as a ".csv" in the paper's supplemental data, but inspecting the file showed that it was actually a tsv file, so I manually changed the file extension
head(full.indiv)
pre.indiv <- tibble(Accession=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
indiv.join <- left_join(pre.indiv, full.indiv) # join by accession
plyr::count(is.na(indiv.join$species)) # VERY few lines joined successfully. Why?
# inspect the conflicts and overlap:
geno.only <- setdiff(colnames(eigensoft.geno), full.indiv$Accession)
indiv.only <- setdiff(full.indiv$Accession, colnames(eigensoft.geno))
shared <- intersect(colnames(eigensoft.geno), full.indiv$Accession)
plyr::count(is.na(indiv.join$species)) # Less than half joined successfully. Why?
head(geno.only)
geno.only[10:30]
"Heinz_1706" %in% colnames(eigensoft.geno)
"Heinz_1706" %in% full.indiv$Accession
indiv.join <- left_join(pre.indiv, full.indiv, by=c("Accession"="sample")) # join by accession
indiv.join <- left_join(pre.indiv, full.indiv, by=c("Accession"="Sample")) # join by accession
plyr::count(is.na(indiv.join$species)) # Less than half joined successfully. Why?
indiv.join <- left_join(pre.indiv, full.indiv) # join by accession
plyr::count(is.na(indiv.join$species)) # Less than half joined successfully. Why?
plyr::count(full.indiv$Sample==full.indiv$Accession)
View(full.indiv[(full.indiv$Sample==full.indiv$Accession)])
View(full.indiv[(full.indiv$Sample==full.indiv$Accession),])
View(full.indiv[!(full.indiv$Sample==full.indiv$Accession),])
pre.indiv <- tibble(line=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by accession
plyr::count(is.na(indiv.join$species)) # Less than half joined successfully. Why?
View(indiv.join)
View(colnames(eigensoft.geno))
View(full.indiv)
full.indiv$Sample <- gsub("\,", "\.", full.indiv$Sample)
full.indiv$Sample <- gsub(",", "\.", full.indiv$Sample)
full.indiv$Sample <- gsub("\\,", "\\.", full.indiv$Sample)
full.indiv
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.txt") # this file was attached as a ".csv" in the paper's supplemental data, but inspecting the file showed that it was actually a tsv file, so I manually changed the file extension
pre.indiv <- tibble(line=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
full.indiv$Sample <- gsub("\\,", "\\.", full.indiv$Sample) # switch commas to periods
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
#Now only 3 are not joined, so manually edit these to match:
full.indiv$Sample <- gsub("PAS16398", "pas16398", full.indiv$Sample) # change case
full.indiv$Sample <- gsub("PAS16401", "pas16401", full.indiv$Sample) # change case
full.indiv$Sample <- gsub("PI 379051", "PI_379051", full.indiv$Sample) # change space to underscore
# try to join now:
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
stopifnot(sum(is.na(indiv.join$species))==0)
# extract needed columns
full.eigensoft.indiv <- indiv.join %>%
select(line, gender, species)
# output file
write_tsv(full.eigensoft.indiv, "full.eigensoft.indiv", col_names = F)
setwd("C:/Users/ltibbs/Box Sync/ISU/2018 fall/BCB 546X Computational Skills for Bio Data/final project")
plyr::count(unique(full.eigensoft.indiv$species))
plyr::count((full.eigensoft.indiv$species))
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/ltibbs/Box Sync/ISU/2018 fall/BCB 546X Computational Skills for Bio Data/final project")
library(tidyverse)
library(readxl)
full.geno <- read_csv("supplemental/Suppl_Table_2.csv")
head(full.geno)
tr.geno <- as_tibble(cbind(SNPs=colnames(full.geno), t(full.geno))) # transpose full.geno and cbind the SNP names to it
colnames(tr.geno) <- tr.geno[1,] # add the column names since they were moved to row 1 by t()
tr.geno <- tr.geno[-1,] # remove row 1 now that column names are where they should be
head(tr.geno) # visually inspect transposed geno file
num.geno <- tr.geno %>%
unite(united, -1, sep="", remove=F) %>%
mutate(count.A=str_count(united, "A"), # count each nucleotide in the SNPs
count.C=str_count(united,"C"),
count.G=str_count(united, "G"),
count.T=str_count(united,"T"),
max.count=pmax(count.A, count.C, count.G, count.T), # find the max count of any NT for a given SNP
ref.allele=ifelse(count.A==max.count, "A", # set the reference allele
ifelse(count.C==max.count, "C",
ifelse(count.G==max.count, "G", "T")))
) %>%
group_by(ref.allele) # group by reference allele value
# split the genotype data into tibbles each with the same reference allele, and store these in a list
split.num.geno <- split(num.geno, num.geno$ref.allele)
# loop through each tibble in the list to replace homozygous reference as 2, het as 1, missing as 9, and other as 0:
for (i in 1:length(split.num.geno)) {
ref <- unique(split.num.geno[[i]]$ref.allele) # save ref allele
stopifnot(length(ref)==1) # check that there was only one ref allele in the table
geno.index <- ncol(split.num.geno[[i]])-6 # store the index of the last column with genotype data
# make string of heterozygous genotypes to match (code idea from https://stackoverflow.com/questions/35366803/how-to-use-gsub-for-the-list-of-multiple-patterns-in-r)
het.list <- list(paste(ref, "A", sep=""), paste(ref, "C", sep=""), paste(ref, "G", sep=""), paste(ref, "T", sep=""),
paste("A", ref, sep=""), paste("C", ref, sep=""), paste("G", ref, sep=""), paste("T", ref, sep="")) # list possible het genotypes (refref genotype will also occur in this list, but will not be matched because that pattern will be replaced first)
het.string <- paste(unlist(het.list), collapse="|") # convert this list into a string separated by | to match any of these patterns
split.num.geno[[i]] <- split.num.geno[[i]] %>% # in the following lines, use c(2:geno.index) to make replacements only in the coluns containing genotype data
mutate_at(c(2:geno.index), funs(replace(., is.na(.), "9"))) %>% # replace missing data with 9
mutate_at(c(2:geno.index), funs(str_replace_all(., paste(ref, ref, sep=""), "2"))) %>% # replace homozygous ref genotypes with 2
mutate_at(c(2:geno.index), funs(str_replace_all(., het.string, "1"))) %>% # replace het genotypes with 1
mutate_at(c(2:geno.index), funs(str_replace_all(., "[[:upper:]]{2}", "0"))) %>% # replace all remaining genotypes with 0
select(-count.A, -count.C, -count.T, -count.G, -united, -max.count) # remove non-genotype columns
}
eigensoft.geno <- do.call("rbind", split.num.geno) %>% # combine tibbles in list
ungroup() %>%
select(-ref.allele, -X1) # remove unneeded columns
# save the full dataset in eigensoft format
full.eigensoft.geno <- unite(eigensoft.geno, united, sep="", remove=T) # collapse all SNPs into one line
# output file
write_tsv(full.eigensoft.geno, "full.eigensoft.geno", col_names = F)
full.indiv <- read_tsv("12864_2015_1444_MOESM1_ESM.txt") # this file was attached as a ".csv" in the paper's supplemental data, but inspecting the file showed that it was actually a tsv file, so I manually changed the file extension
head(full.indiv)
pre.indiv <- tibble(line=colnames(eigensoft.geno), gender=c(rep("U", length(colnames(eigensoft.geno)))))
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
# After manual inspection, some of the problems seem to be:
# different cases (upper vs lower; lowercase in pre.indiv),
# periods vs commas (periods in pre.indiv),
# and spaces vs underscores (underscores in pre.indiv)
# So, manually edit full.indiv so that it will match pre.indiv:
full.indiv$Sample <- gsub("\\,", "\\.", full.indiv$Sample) # switch commas to periods
# try to join now:
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # but not everything joined; why?
#Now only 3 are not joined, so manually edit these to match:
full.indiv$Sample <- gsub("PAS16398", "pas16398", full.indiv$Sample) # change case
full.indiv$Sample <- gsub("PAS16401", "pas16401", full.indiv$Sample) # change case
full.indiv$Sample <- gsub("PI 379051", "PI_379051", full.indiv$Sample) # change space to underscore
# try to join now:
indiv.join <- left_join(pre.indiv, full.indiv, by=c("line"="Sample")) # join by sample ID
plyr::count(is.na(indiv.join$species)) # Now everything has joined
stopifnot(sum(is.na(indiv.join$species))==0) # sanity check--stop if not everything has joined
practice.snp <- tibble(num.geno$X1, c(rep("1", length(num.geno$X1))), c(rep(0.0, length(num.geno$X1))), c(1:length(num.geno$X1)))
write_tsv(practice.snp, "practice.snp", col_names = F)
setwd("C:/Users/ltibbs/Box Sync/ISU/2018 fall/BCB 546X Computational Skills for Bio Data/BCB546X_MadMaize_final/code/PCA")
knitr::opts_chunk$set(echo = TRUE)
full.geno <- read_csv("../../data/Suppl_Table_2.csv")
library(tidyverse)
library(readxl)
full.geno <- read_csv("../../data/Suppl_Table_2.csv")
